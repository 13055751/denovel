import { parseArgs } from "jsr:@std/cli/parse-args";
import { basename, dirname } from "jsr:@std/path";
import { EPub, EpubContentOptions, EpubOptions } from "./genepub.ts";
import { exists } from "./main.ts";
import { ensureDir } from "jsr:@std/fs@^1.0.10/ensure-dir";

// deno-lint-ignore no-control-regex
const rep = /[\x00-\x1F\x7F-\x9F\u200B-\u200F\uFEFF]/g;

// 1~奇怪的传单
// chapter 1~偷吃？不，没有
// No、001姬的时代
// 倒仙初淋夏时雨 : 001 无家可归的夏大小姐
//  1~猎魔人？求爱？
const regexp = [
    /[\r\n]+(?:\s*第[-零一二三四五六七八九十百千万亿0-9]+卷[ :：]*)?\s*第\s*[-一二三四五六七八九十百千万亿0-9]+\s*[章话]\s*(.+)[\r\n]+/g,
    /[\r\n]+\s*(chapter\s*)[零一二三四五六七八九十百千万亿0-9]+\s*[、. ：:~，]\s*(.+)[\r\n]+/g,
    /[\r\n]+\s*\d+＜(.+)＞\s*[\r\n]+/gi,
    /[\r\n]+\s*No[、.]\d+\s*(.+)\s*[\r\n]+/g,
    /[\r\n]+.+\s*[：:]\s*\d+\s*(.+)\s*[\r\n]+/g,
    /第\s*[-零一二三四五六七八九十百千万亿0-9]+\s*章\s*(.+)/g,
    /[\r\n]\s*\d+\s*[、. ：:~，]\s*(.+)\s*[\r\n]+/g,
];

/**
 * TXT转换成EPUB
 * @param data 输入的文件内容
 * @param input 输入的文件名
 * @param output 输出位置
 */
export function toEpub(data: string, input: string, output: string, thenCB?: () => any): boolean {
    input = input ? input.replace('.txt', '') : '<inmemory>';

    // 分卷
    const chaps: Array<EpubContentOptions> = [];
    let max: number = 0;

    let matches: Array<RegExpExecArray> = [];
    for(const reg of regexp){
        matches = Array.from(data.matchAll(reg));
        max = Math.max(max, matches.length);
        if(matches.length * 1e5 >= data.length) break;
    }
    // 每章1w字峰值，阈值10w
    if(matches.length * 1e5 < data.length){
        console.error(`章节数过少，疑似分片错误，请确保章节数 >= 1且遵循 “第x章 ....”`);
        console.error(input, '生成失败', 'count: ', max, 'length: ', data.length, 'adv: ', data.length / max);
        return false;
    }
    let start = matches[0].index;

    // debug
    if(output == undefined){
        console.log(matches.map(m => m[1]).join('\n'));
        return false;
    }

    for (let i = 1; i <= matches.length; i++) {
        const content = data.substring(matches[i - 1].index, matches[i]?.index),
            title = matches[i - 1][1].substring(0, 50) + (matches[i-1][1].length > 50 ? '...' : '');

        chaps.push({
            title,
            data: encodeContent(content).replaceAll(/\[img\=\d+,\d+\](.+?)\[\/img\]/g, (_,it) =>
                it ? `<img src="${it}" />` : ''
            ),
        });
    }

    const options: EpubOptions = {
        title: basename(input),
        description: "Generated by 2epub",
        content: chaps,
        // verbose: true,
        downloadAudioVideoFiles: true,
        lang: "zh-CN",
    }

    if(start > 0){
        data = data.substring(0, start);
        chaps.unshift({
            title: "前言",
            data: encodeContent(data)
        });

        const match = data.match(/[\r\n]+\s*作者[：:]\s*(.+?)\s*[\r\n]+/);
        if(match){
            options.author = match[1];
        }

        // const ctxmatch = data.match(/[\r\n]+\s*简介[：:]\s*[\r\n]+/);
        // if(ctxmatch){
        //     const start = ctxmatch.index + ctxmatch[0].length;
        //     const end = start.match(/[\r\n]+\s*[\r\n]+/)
        // }

        // image
        const imgmatch = data.match(/https?:\/\/[^\s]+\.(jpg|jpeg|png|gif)/);
        if(imgmatch){
            options.cover = imgmatch[0];
        }
    }

    // 生成 epub 文件
    console.log('Generating EPub file to ', output, '...');
    new EPub(options, output).render().then(a => {
        console.log('EPub has been generated to ',output, a.result);
        if(thenCB) thenCB();
    });

    return true;
}

export const encodeContent = (str: string) => {
    const str2 = '<p>' + str.replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;')
        .replace(/\s*[\r\n]+\s*/g, '</p><p>')
        .replace(rep, '')
        .replaceAll(/\&lt\;img.+src=\&(?:quot|apos)\;(.+?)\&(?:quot|apos)\;.*\/?\&gt;/g, '<img src="$1" />')
        + '</p>';
    return str2.replaceAll(/\<p\> *\<\/p\>/g, '');
}

if (import.meta.main) {
    const args = parseArgs(Deno.args, {
        string: ['output'],
        boolean: ['help', 'delete'],
        alias: {
            o: 'output',
            h: 'help',
            d: 'delete'
        }
    });

    if (args.help) {
        console.log(`Convert TXT to EPUB file
    
    Usage:
      deno run 2epub.ts [options] <input>
    
    Options:
        -o, --output <output>  Output dir (default: auto-generated)
        -h, --help             Show help
        -d, --delete           Delete input file after conversion
    
    Example:
      deno run 2epub.ts input.txt -o output.epub`);
        Deno.exit(0);
    }

    const input = args._[0];
    const output = dirname(args.output || input as string);
    if (typeof input !== 'string')
        throw new Error('Input file is required');
    const finfo = await Deno.stat(input);
    let files = [] as string[];
    if(finfo.isDirectory) {
        files = await Array.fromAsync(Deno.readDir(input)).then(data => 
            data.filter(item => item.isFile && item.name.endsWith('.txt')).map(item => item.name)
        );
    } else {
        files = [input];
    }

    console.time('convert');
    await ensureDir(output);
    for(const file of files) try{
        const ofile = output + '/' + basename(file) + '.epub';
        if(await exists(ofile)){
            console.log(`"${ofile}" already exists, skip`);
            continue;
        }
        
        const data = Deno.readTextFileSync(file);
        const res = toEpub(data, file, ofile);
        if(res)
            console.log(`"${file}" has been converted to "${basename(file)}.epub"`);
        console.timeLog('convert');
        if(args.delete && res) Deno.removeSync(file);
    }catch(e) {
        console.error(`Error converting "${file}": ${(e as Error).message}`);
    }
    console.timeEnd('convert');

    console.log('Done!');
}